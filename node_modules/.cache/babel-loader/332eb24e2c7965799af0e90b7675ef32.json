{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nexport var clamp = function clamp(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n};\nexport function precisionRound(number) {\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var factor = Math.pow(10, precision);\n  return Math.round(number * factor) / factor;\n}\nexport function rescale(value, from, to) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var res = clamp.apply(void 0, [(value - from[0]) / (from[1] - from[0]) * (to[1] - to[0]) + to[0]].concat(_toConsumableArray(to)));\n  var _options$step = options.step,\n      step = _options$step === void 0 ? 0 : _options$step;\n\n  if (step > 0) {\n    var stepFloatPart = \"\".concat(step).split('.')[1] || '';\n    return precisionRound(Math.round(res / step) * step, stepFloatPart.length);\n  }\n\n  return res;\n}","map":{"version":3,"sources":["../../src/helpers/math.ts"],"names":["clamp","Math","precision","factor","number","options","res","value","from","to","step","stepFloatPart","precisionRound"],"mappings":";AAAA,OAAO,IAAMA,KAAK,GAAG,SAARA,KAAQ,CAAA,KAAA,EAAA,GAAA,EAAA,GAAA,EAAA;AAAA,SAA6CC,IAAI,CAAJA,GAAAA,CAAAA,GAAAA,EAAcA,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,EAA3D,GAA2DA,CAAdA,CAA7C;AAAd,CAAA;AAEP,OAAO,SAAA,cAAA,CAAA,MAAA,EAAuD;AAAA,MAAfC,SAAe,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAH,CAAG;AAC5D,MAAIC,MAAM,GAAGF,IAAI,CAAJA,GAAAA,CAAAA,EAAAA,EAAb,SAAaA,CAAb;AACA,SAAOA,IAAI,CAAJA,KAAAA,CAAWG,MAAM,GAAjBH,MAAAA,IAAP,MAAA;AACD;AAED,OAAO,SAAA,OAAA,CAAA,KAAA,EAAA,IAAA,EAAA,EAAA,EAA+G;AAAA,MAAjCI,OAAiC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AACpH,MAAMC,GAAG,GAAGN,KAAK,CAALA,KAAAA,CAAAA,KAAAA,CAAAA,EAAAA,CAAM,CAACO,KAAK,GAAGC,IAAI,CAAb,CAAa,CAAb,KAAqBA,IAAI,CAAJA,CAAI,CAAJA,GAAUA,IAAI,CAAnC,CAAmC,CAAnC,KAA2CC,EAAE,CAAFA,CAAE,CAAFA,GAAQA,EAAE,CAArD,CAAqD,CAArD,IAA4DA,EAAE,CAApET,CAAoE,CAApEA,EAAAA,MAAAA,CAAAA,kBAAAA,CAAZ,EAAYA,CAAAA,CAAAA,CAAZ;AADoH,MAAA,aAAA,GAG/FK,OAH+F,CAAA,IAAA;AAAA,MAG5GK,IAH4G,GAAA,aAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,aAAA;;AAIpH,MAAIA,IAAI,GAAR,CAAA,EAAc;AACZ,QAAMC,aAAa,GAAG,GAAA,MAAA,CAAA,IAAA,EAAA,KAAA,CAAA,GAAA,EAAA,CAAA,KAAtB,EAAA;AACA,WAAOC,cAAc,CAACX,IAAI,CAAJA,KAAAA,CAAWK,GAAG,GAAdL,IAAAA,IAAD,IAAA,EAAgCU,aAAa,CAAlE,MAAqB,CAArB;AACD;;AAED,SAAA,GAAA;AACD","sourcesContent":["export const clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(value, max));\n\nexport function precisionRound(number: number, precision = 1) {\n  let factor = Math.pow(10, precision);\n  return Math.round(number * factor) / factor;\n}\n\nexport function rescale(value: number, from: [number, number], to: [number, number], options: { step?: number } = {}) {\n  const res = clamp((value - from[0]) / (from[1] - from[0]) * (to[1] - to[0]) + to[0], ...to);\n\n  const { step = 0 } = options;\n  if (step > 0) {\n    const stepFloatPart = `${step}`.split('.')[1] || '';\n    return precisionRound(Math.round(res / step) * step, stepFloatPart.length);\n  }\n\n  return res;\n}\n"]},"metadata":{},"sourceType":"module"}